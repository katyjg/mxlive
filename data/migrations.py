from lims.models import Data, AnalysisReport, SpaceGroup, Session, Project, Beamline, Stretch

import json
import itertools
import collections
import datetime


_h = 4.13566733e-15  # eV.s
_c = 299792458e10  # A/s


def wavelength_to_energy(wavelength):
    """Convert energy in keV to wavelength in angstroms."""
    if wavelength == 0.0:
        return 0.0
    return round((_h * _c) / (wavelength * 1000.0), 4)


def merge_accounts(auth, proj):
    """
    Merges user and project data from past MxLIVE installations so the Project model can inherit from the AbstractUser class.
    :param auth: filename pointing to a json file generated by ./manage.py dumpdata auth.user
    :param proj: filename pointing to a json file generated by ./manage.py dumpdata lims.project
    :return: file named merged-accounts.json ready to be installed via ./manage.py loaddata
    """
    fa = open(auth)
    fp = open(proj)
    dauth = json.load(fa)
    dproj = json.load(fp)
    fa.close()
    fp.close()

    auth = {}
    for user in dauth:
        auth[user['fields']['username']] = user['fields']

    merged = []
    for project in dproj:
        project['fields'].update(auth[project['fields']['name']])
        del(project['fields']['user'])
        merged.append(project)

    fm = open('merged-accounts.json','w')
    fm.write(json.dumps(merged, indent=2))
    fm.close()


def clean_securepaths(mxlive):
    """
    :param mxlive: filename pointing to a json file generated by ./manage.py dumpdata
    :return: file named download-paths.json ready to be installed to data server via ./manage.py loaddata
    """
    fm = open(mxlive)
    data = json.load(fm)
    fm.close()

    data = [d for d in data if d['model'] == 'download.securepath']
    for i, d in enumerate(data):
        data[i]['fields'].pop('owner')
        data[i]['model'] = 'downloads.securepath'

    filename = open('download-paths.json','w')
    filename.write(json.dumps(data, indent=2))
    filename.close()


def cleanup(mxlive, verbose=False):
    """
    :param mxlive: filename pointing to a json file generated by ./manage.py dumpdata -e contenttypes -e auth -e admin -e reversion --natural
    :param verbose: print more information as the function is running
    :return: files named mxlive-clean.json and download-paths.json ready to be installed to mxlive and dataserver dbs respectively via ./manage.py loaddata
    """
    fm = open(mxlive)
    data = json.load(fm)
    fm.close()

    download_data = [d for d in data if d['model'] == 'download.securepath']
    for i, d in enumerate(download_data):
        download_data[i]['fields'].pop('owner')
        download_data[i]['model'] = 'downloads.securepath'

    filename = open('download-paths.json','w')
    filename.write(json.dumps(download_data, indent=2))
    filename.close()

    remove_models = ['lims.cocktail','lims.crystalform','lims.project','lims.spacegroup','lims.strategy', 'lims.component']
    data = [d for d in data if d['model'] not in remove_models]

    models = ['lims.carrier','lims.beamline','lims.data','lims.dewar','lims.container',
              'lims.shipment','lims.crystal','lims.experiment','lims.result','lims.scanresult']

    entries = {m: {d['pk']: d for d in data if d['model'] == m} for m in models}

    shown = []

    print("Cleaning up {} carriers".format(len(entries['lims.carrier'])))
    # Transfer dewar__storage_location to shipment__storage_location
    for pk, carrier in entries['lims.carrier'].items():
        if verbose and 'lims.carrier' not in shown:
            print(carrier)
            shown.append('lims.carrier')
        for f in ['phone_number', 'fax_number', 'code_regex']:
            entries['lims.carrier'][pk]['fields'].pop(f)

    print("Cleaning up {} dewars".format(len(entries['lims.dewar'])))
    # Transfer dewar__storage_location to shipment__storage_location
    for pk, shipment in entries['lims.shipment'].items():
        dewar_locations = [v['fields']['storage_location'] for k, v in entries['lims.dewar'].items() if v['fields']['shipment'] == pk and v['fields']['storage_location']]
        entries['lims.shipment'][pk]['fields']['storage_location'] = ';'.join(dewar_locations)

    print("Cleaning up {} containers".format(len(entries['lims.container'])))
    # Transfer container__dewar__shipment to container__shipment
    kind_map = {1: 1, 0: 2, 2: 3, 3: 4}
    for pk, container in entries['lims.container'].items():
        if verbose and 'lims.container' not in shown:
            print(container)
            shown.append('lims.container')
        if container['fields'].get('dewar'):
            entries['lims.container'][pk]['fields']['shipment'] = entries['lims.dewar'][container['fields']['dewar']]['fields']['shipment']
        entries['lims.container'][pk]['fields'].pop('dewar')
        entries['lims.container'][pk]['fields'].pop('staff_priority')
        # Transfer container__kind to instance of ContainerType
        entries['lims.container'][pk]['fields']['kind'] = kind_map[container['fields']['kind']]

    print("Cleaning up {} experiments".format(len(entries['lims.experiment'])))
    for pk, group in entries['lims.experiment'].items():
        if verbose and 'lims.experiment' not in shown:
            print(group)
            shown.append('lims.experiment')
        entries['lims.experiment'][pk]['model'] = 'lims.group'
        for f in ['i_sigma','multiplicity','r_meas','resolution','total_angle','delta_angle','staff_priority']:
            entries['lims.experiment'][pk]['fields'].pop(f)
        samples = [e for e in entries['lims.crystal'].values() if e['fields']['experiment'] == pk]
        shipments = [entries['lims.container'][c]['fields'].get('shipment') for c in [s['fields']['container'] for s in samples if s['fields']['container']] if entries['lims.container'][c]['fields'].get('shipment')]
        if shipments:
            shipment = max(set(shipments), key=shipments.count)
            entries['lims.experiment'][pk]['fields']['shipment'] = shipment
        entries['lims.experiment'][pk]['fields']['sample_count'] = len(samples)

    print("Cleaning up {} crystals".format(len(entries['lims.crystal'])))
    for pk, sample in entries['lims.crystal'].items():
        if verbose and 'lims.crystal' not in shown:
            print(sample)
            shown.append('lims.crystal')
        entries['lims.crystal'][pk]['model'] = 'lims.sample'
        entries['lims.crystal'][pk]['fields'].pop('crystal_form')
        entries['lims.crystal'][pk]['fields'].pop('cocktail')
        entries['lims.crystal'][pk]['fields'].pop('staff_priority')
        for f in ['status', 'screen_status', 'collect_status', 'staff_priority', 'pin_length', 'loop_size']:
            if f in entries['lims.crystal'][pk]['fields']: entries['lims.crystal'][pk]['fields'].pop(f)
        entries['lims.crystal'][pk]['fields']['group'] = entries['lims.crystal'][pk]['fields'].pop('experiment')
        entries['lims.crystal'][pk]['fields']['location'] = entries['lims.crystal'][pk]['fields'].pop('container_location')

    print("Cleaning up {} results".format(len(entries['lims.result'])))
    for pk, result in entries['lims.result'].items():
        if verbose and 'lims.result' not in shown:
            print(result)
            shown.append('lims.result')
        entries['lims.result'][pk]['fields'].pop('strategy')
        entries['lims.result'][pk]['model'] = 'lims.analysisreport'
        entries['lims.result'][pk]['fields']['data'] = [result['fields']['data']]
        entries['lims.result'][pk]['fields'].pop('crystal')
        entries['lims.result'][pk]['fields'].pop('experiment')
        details = json.loads(entries['lims.result'][pk]['fields']['details'])
        for f in ['space_group', 'cell_a', 'cell_b', 'cell_c', 'cell_alpha', 'cell_beta', 'cell_gamma', 'resolution',
                  'reflections', 'unique', 'multiplicity', 'completeness', 'mosaicity', 'wavelength', 'i_sigma',
                  'r_meas', 'r_mrgdf', 'cc_half', 'sigma_spot', 'sigma_angle', 'ice_rings']:
            if f in entries['lims.result'][pk]['fields'].keys():
                details[f] = entries['lims.result'][pk]['fields'].pop(f)
        entries['lims.result'][pk]['fields']['details'] = json.dumps(details)

    print("Cleaning up {} data".format(len(entries['lims.data'])))
    data_kind_map = {0: "MX_SCREEN", 1: "MX_DATA"}
    for pk, data in entries['lims.data'].items():
        if verbose and 'lims.data' not in shown:
            print(data)
            shown.append('lims.data')
        entries['lims.data'][pk]['fields']['file_name'] = "{}_".format(data['fields']['name']) + "{:0>4d}." + "{}".format('PILATUS' in data['fields']['detector'] and 'cbf' or 'img')
        entries['lims.data'][pk]['fields']['sample'] = entries['lims.data'][pk]['fields'].pop('crystal')
        entries['lims.data'][pk]['fields']['kind'] = data_kind_map[data['fields']['kind']]
        entries['lims.data'][pk]['fields']['group'] = entries['lims.data'][pk]['fields'].pop('experiment')
        entries['lims.data'][pk]['fields']['frames'] = entries['lims.data'][pk]['fields'].pop('frame_sets')
        entries['lims.data'][pk]['fields']['energy'] = wavelength_to_energy(entries['lims.data'][pk]['fields'].pop('wavelength'))
        entries['lims.data'][pk]['fields'].pop('first_frame')
        meta = {
            field: entries['lims.data'][pk]['fields'].pop(field)
            for field in ['delta_angle', 'start_angle', 'resolution', 'detector', 'detector_size', 'pixel_size', 'beam_x', 'beam_y', 'two_theta']
        }
        entries['lims.data'][pk]['fields']['meta_data'] = json.dumps(meta)

    print("Cleaning up {} scans".format(len(entries['lims.scanresult'])))
    scan_kind_map = {1: "XRF_SCAN", 0: "MAD_SCAN"}
    for pk, scan in entries['lims.scanresult'].items():
        if verbose and 'lims.scanresult' not in shown:
            print(scan)
            shown.append('lims.scanresult')
        entries['lims.scanresult'][pk]['model'] = 'lims.data'
        entries['lims.scanresult'][pk].pop('pk')
        if 'strategy' in entries['lims.scanresult'][pk]['fields']:
            entries['lims.scanresult'][pk]['fields'].pop('strategy')
        entries['lims.scanresult'][pk]['fields']['sample'] = entries['lims.scanresult'][pk]['fields'].pop('crystal')
        entries['lims.scanresult'][pk]['fields']['group'] = entries['lims.scanresult'][pk]['fields'].pop('experiment')
        entries['lims.scanresult'][pk]['fields']['meta_data'] = json.dumps({'edge': entries['lims.scanresult'][pk]['fields'].pop('edge')})
        entries['lims.scanresult'][pk]['fields']['kind'] = scan_kind_map[scan['fields']['kind']]
        entries['lims.scanresult'][pk]['fields'].pop('details')

    new_data = []
    models = [m for m in models if m != 'lims.dewar']
    for m in models:
        new_data.extend(entries[m].values())

    filename = open('mxlive-cleaned.json','w')
    filename.write(json.dumps(new_data, indent=2))
    filename.close()


def post_clean(directory_map):
    """
    Combines methods that should be run after populating database with historic information.
    :param directory_map: filename pointing to a json file generated from dataserver (dictionary mapping directories to keys)
    :return:
    """
    build_sessions(directory_map)
    format_reports()


def build_sessions(directory_map):
    """
    Should only be run after database is populated with Data objects
    :param directory_map: filename pointing to a json file generated from dataserver (dictionary mapping directories to keys)
    :return: success message after creating sessions in the database
    """
    fm = open(directory_map)
    directories = json.load(fm)
    fm.close()

    for directory, data_ids in directories.items():
        try:
            try:
                data = Data.objects.filter(url__in=data_ids)
            except:
                pks = itertools.chain.from_iterable([Data.objects.filter(url=id).values_list('pk', flat=True) for id in data_ids])
                data = Data.objects.filter(pk__in=list(pks))
            bls = collections.Counter(data.values_list('beamline__pk', flat=True))
            if data.count() and len(bls):
                bl = Beamline.objects.filter(pk=bls.most_common(1)[0][0]).first()
                uname = directory.split('/')[-2]
                project = Project.objects.get(username=uname)
                name = directory.split('/')[-1]
                session, created = Session.objects.get_or_create(project=project, name=name, beamline=bl)
                data.update(session=session)
                records = list(data.order_by('created').values_list('created', flat=True))
                to_create = []
                info = {
                    'session': session,
                    'start': records[0],
                    'end': None,
                }
                create = False
                for i, record in enumerate(records):
                    if record > (info['start'] + datetime.timedelta(hours=4)):
                        info['end'] = records[i-1]
                        create = True
                    if create:
                        to_create.append(Stretch(**info))
                        info['start'] = record
                        create = False
                Stretch.objects.bulk_create(to_create)

        except:
            print("Unable to create session for", directory)
    return "Done building sessions"



def format_reports():
    """Should only be run after database is populated with AnalysisReport objects"""
    for r in AnalysisReport.objects.filter(kind='1'):
        print(r.pk)
        details = isinstance(r.details, list) and r.details[-1] or r.details
        
        collect_details = [{
            'title': 'Summary',
            'description': """[1] - Data Quality Score for comparing similar data sets. Typically, values >
                    0.8 are excellent, > 0.6 are good, > 0.5 are acceptable, > 0.4
                    marginal, and &lt; 0.4 are Barely usable
                [2] - This space group was automatically assigned using POINTLESS (see P.R.Evans,
                    Acta Cryst. D62, 72-82, 2005). This procedure is unreliable for incomplete datasets
                    such as those used for screening. Please Inspect the detailed results below.
                [3] - Data collection strategy and predicted quality was calculated using BEST. See
                A.N. Popov and G.P. Bourenkov Acta Cryst. (2003). D59, 1145-1153, G.P. Bourenkov and A.N. Popov Acta Cryst. (2006). D62, 58-64.
                [4] - {}.
                """.format(details.get('resolution_method', details.get('strategy', {}).get('resolution_reasoning'))),
            'style': 'summary',
            'content': [
                {
                    'title': 'Observed Parameters',
                    'kind': 'table',
                    'data': [['Score[1]', r.score],
                             ['Wavelength (A)', details['wavelength']],
                             ['Space Group[2]', SpaceGroup.objects.get(pk=details['space_group']).name],
                             ['Unit Cell (A)',
                              "{} {} {} {} {} {}".format(details['cell_a'], details['cell_b'], details['cell_c'], details['cell_alpha'], details['cell_beta'],
                                                         details['cell_gamma'])],
                             ['Resolution', details['resolution']],
                             ['All Reflections', details['reflections']],
                             ['Unique Reflections', details['unique']],
                             ['Multiplicity', details['multiplicity']],
                             ['Completeness', details['completeness']],
                             ['Mosaicity', details['mosaicity']],
                             ['I/Sigma(I)', details['i_sigma']],
                             ['R-meas[4]', details['r_meas']],
                             details.get('cc_half') and ['CC(1/2)[5]', details['cc_half']] or ['R-mrgd-F[5]', getattr(details, 'r_mrgd', 'unknown')],
                             ['Spot deviation', details['sigma_spot']],
                             details.get('ice_rings', -1) != -1 and ['Ice Rings', details['ice_rings']]
                    ],
                    'header': 'column',
                    'notes': """[1] - Data Quality Score for comparing similar data sets. Typically, values > 0.8 are excellent, > 0.6 are good, > 0.5 are acceptable, > 0.4 marginal, and < 0.4 are Barely usable
                                      [2] - This space group was automatically assigned using POINTLESS (see P.R.Evans, Acta Cryst. D62, 72-82, 2005). This procedure is unreliable for incomplete datasets such as those used for screening. Please Inspect the detailed results below.
                                      [3] - Resolution selected based on a cut-off of I/sigma(I) > 1.0. Statistics presented reflect this resolution.
                                      [4] - Redundancy independent R-factor. (see Diederichs & Karplus, 1997, Nature Struct. Biol. 4, 269-275.)
                                      [5] - {}""".format(details.get('cc_half') and """Percentage correlation between intensities from random half-datasets. (see Karplus & Diederichs (2012), Science. 336 (6084): 1030-1033)""" or """Quality of amplitudes. (see Diederichs & Karplus, 1997, Nature Struct. Biol. 4, 269-275.)""")
                },
                {
                    'title': "Compatible bravais lattice types",
                    'kind': 'table',
                    'data': [['No.', 'Lattice type', 'Cell Parameters', 'Quality', 'Cell Volume']] + [
                        [id, details['compatible_lattices']['type'][i],
                         details['compatible_lattices']['unit_cell'][i], details['compatible_lattices']['quality'][i],
                         details['compatible_lattices']['volume'][i]]
                        for i, id in enumerate(details['compatible_lattices']['id'])
                        ],
                    'header': 'row',
                },
                {
                    'title': "Automatic Space-Group Selection",
                    'kind': 'table',
                    'data': [['Selected', 'Candidates', 'Space Group No.', 'Probability']] + [
                        [prob == max(details['spacegroup_selection']['probability']) and '*' or '',
                         details['spacegroup_selection']['name'][i],
                         details['spacegroup_selection']['space_group'][i],
                         prob,
                         ]
                        for i, prob in enumerate(details['spacegroup_selection']['probability'])],
                    'header': 'row',
                    'notes': """The above table contains results from POINTLESS (see Evans, Acta Cryst. D62, 72-82, 2005). Indistinguishable space groups will have similar probabilities. If two or more of the top candidates have the same probability, the one with the fewest symmetry assumptions is chosen. This usually corresponds to the point group,  trying out higher symmetry space groups within the top tier does not require re-indexing the data as they are already in the same setting. For more detailed results, please inspect the output file 'pointless.log'."""
                }
            ]
        },{
            'title': 'Standard errors of reflection intensities by resolution',
            'content': [
                {
                    'kind': 'lineplot',
                    'data':
                        {
                            'x': ['Resolution Shell']+ details['standard_errors']['shell'],
                            'y1': [['Chi^2']+ details['standard_errors']['chi_sq']],
                            'y2': [['I/Sigma']+ details['standard_errors']['i_sigma']],
                            'x-scale': 'inv-square'
                        }
                }, {
                    'kind': 'lineplot',
                    'data':
                        {
                            'x': ['Resolution Shell'] + details['standard_errors']['shell'],
                            'y1': [['R-observed'] + details['standard_errors']['r_obs'],['R-expected'] + details['standard_errors']['r_exp']],
                            'y1-label': 'R-factors (%)',
                            'x-scale': 'inv-square'
                        }

                },],
            'description': """I/Sigma - Mean intensity/Sigma of a reflection in shell
                              &Chi;<superscript>2</superscript> - Goodness of fit between sample variances of symmetry-related intensities and their errors (&Chi;<superscript>2</superscript> = 1 for perfect agreement).
                              R-observed - &Sigma;|I(h,i)-I(h)| / &Sigma;[I(h,i)]
                              R-expected - Expected R-FACTOR derived from Sigma(I) """

        },{
            'title': 'Statistics of final reflections by shell',
            'content': [
                {
                    'kind': 'lineplot',
                    'data': {
                        'x': ['Resolution Shell'] + details['shell_statistics']['shell'],
                        'y1': [['Completeness (%)']+ details['shell_statistics']['completeness']],
                        'y2': [['R-meas']+ details['shell_statistics']['r_meas'],['CC_1/2']+ details['shell_statistics'].get('cc_half', details['shell_statistics'].get('r_mrgdf',[]))],
                        'y2-label': 'R-factors (%)'
                    }
                },
                {
                    'kind': 'lineplot',
                    'data': {
                        'x': ['Resolution Shell'] + details['shell_statistics']['shell'],
                        'y1': [['I/Sigma(I)'] + details['shell_statistics']['i_sigma']],
                        'y2': [['SigAno'] + details['shell_statistics']['sig_ano']],
                    }
                },
                {
                    'kind': 'table',
                    'data': [['Shell', 'Completeness', 'R_meas', 'CC_1/2','I/Sigma(I)[1]','SigAno[2]','CC_ano[3]']] + [
                        [shell,
                         details['shell_statistics']['completeness'][i],
                         details['shell_statistics']['r_meas'][i],
                         details['shell_statistics'].get('cc_half', details['shell_statistics'].get('r_mrgdf',[]))[i],
                         details['shell_statistics']['i_sigma'][i],
                         details['shell_statistics']['sig_ano'][i],
                         details['shell_statistics']['cor_ano'][i],
                         ]
                        for i, shell in enumerate(details['shell_statistics']['shell'])],
                    'header': 'row',
                    'notes': """[1] - Mean of intensity/Sigma(I) of unique reflections (after merging symmetry-related observations). Where Sigma(I) is the standard deviation of reflection intensity I estimated from sample statistics.
                                      [2] - Mean anomalous difference in units of its estimated standard deviation (|F(+)-F(-)|/Sigma). F(+), F(-) are structure factor estimates obtained from the merged intensity observations in each parity class.
                                      [3] - Percentage of correlation between random half-sets of anomalous intensity differences. """
                }

            ]
        },{
            'title': 'Statistics of final reflections by frame number and frame number difference',
            'content': [
                {
                    'kind': 'scatterplot',
                    'data': {
                        'x': ['Frame Number'] + details['frame_statistics'].get('frame_no', details['frame_statistics']['frame']),
                        'y1': [['Scale Factor'] + details['frame_statistics']['scale']],
                        'y2': [['Mosaicity'] + details['frame_statistics']['mosaicity']],
                    }
                },{
                    'kind': 'scatterplot',
                    'data': {
                        'x': ['Frame Number'] + details['frame_statistics'].get('frame_no', details['frame_statistics']['frame']),
                        'y1': [['Divergence'] + details['frame_statistics']['divergence']],
                        'y2': 'i_sigma' in details['frame_statistics'] and [['I/Sigma(I)'] + details['frame_statistics']['i_sigma']] or [],
                    }
                }, 'r_meas' in details['frame_statistics'] and {
                    'kind': 'scatterplot',
                    'data': {
                        'x': ['Frame Number'] + details['frame_statistics'].get('frame_no', details['frame_statistics']['frame']),
                        'y1': [['R-meas'] + details['frame_statistics']['r_meas']],
                        'unique' in details['frame_statistics'] and 'y2': [['Unique Reflections'] + details['frame_statistics']['unique']],
                    }
                }, 'diff_statistics' in details and {
                    'kind': 'lineplot',
                    'data': {
                        'x': ['Frame Number'] + details['diff_statistics']['frame_diff'],
                        'y1': [['All'] + details['diff_statistics']['rd'],
                               ['Friedel'] + details['diff_statistics']['rd_friedel'],
                               ['Non-Friedel'] + details['diff_statistics']['rd_non_friedel']],
                        'x-label': 'Rd'
                    },
                    'notes': """The above plot was calculated by XDSSTAT. See Diederichs K. (2006) Acta Cryst D62, 96-101.
                                    Divergence - Estimated Standard Deviation of Beam divergence
                                    Rd - R-factors as a function of frame difference. An increase in R-d with frame difference is suggestive of radiation damage. """
                }
            ]
        },{
            'title': 'Wilson Plot',
            'content': [
                {
                    'kind': 'lineplot',
                    'data': {
                        'x': ['Resolution'] + details['wilson_plot'].get('inv_res_sq'),
                        'y1': ['mean_i' in details['wilson_plot'] and ['<I> Observed'] + details['wilson_plot']['mean_i'],
                               ['<I> Expected'] + details['wilson_plot'].get('expected_i', details['wilson_plot'].get('BO',[]))],
                        'y1-label': '<I>'
                    }
                }
            ]
        },'twinning_l_test' in details and {
            'title': 'L Test for twinning',
            'content': [
                {
                    'kind': 'lineplot',
                    'data': {
                        'x': ['|L|'] + details['twinning_l_test'].get('abs_l'),
                        'y1': [['<I> Observed'] + details['twinning_l_test']['observed'],
                               ['Twinned'] + details['twinning_l_test']['twinned'],
                               ['Untwinned'] + details['twinning_l_test']['untwinned']],
                        'y1-label': 'P(L>=1)'
                    }
                }
            ]
        },
        details
        ]
        print(collect_details, r.pk)
        kind = "{}Processing".format(details.get('anomalous') and 'Anomalous ' or "")
        AnalysisReport.objects.filter(pk=r.pk).update(details=collect_details, kind=kind)



    for r in AnalysisReport.objects.filter(kind='0'):
        print(r.pk)
        details = isinstance(r.details, list) and r.details[-1] or r.details

        if 'standard_errors' not in details.keys():
            screen_details = [{
                'title': 'Predicted Quality and Suggested Strategy',
                'description': """[1] - Data Quality Score for comparing similar data sets. Typically, values >
                        0.8 are excellent, > 0.6 are good, > 0.5 are acceptable, > 0.4
                        marginal, and &lt; 0.4 are Barely usable
                    [2] - This space group was automatically assigned using POINTLESS (see P.R.Evans,
                        Acta Cryst. D62, 72-82, 2005). This procedure is unreliable for incomplete datasets
                        such as those used for screening. Please Inspect the detailed results below.
                    [3] - Data collection strategy and predicted quality was calculated using BEST. See
                    A.N. Popov and G.P. Bourenkov Acta Cryst. (2003). D59, 1145-1153, G.P. Bourenkov and A.N. Popov Acta Cryst. (2006). D62, 58-64.
                    [4] - {}.
                    """.format(details.get('resolution_method', details.get('strategy',{}).get('resolution_reasoning'))),
                'style': 'summary',
                'content': [
                    {
                        'title': 'Observed Parameters',
                        'kind': 'table',
                        'style': 'col-6',
                        'data': [['Score[1]', r.score],
                                 ['Wavelength (A)', details['wavelength']],
                                 ['Space Group[2]', SpaceGroup.objects.get(pk=details['space_group']).name],
                                 ['Unit Cell (A)',
                                  "{} {} {} {} {} {}".format(details['cell_a'], details['cell_b'],
                                                             details['cell_c'],
                                                             details['cell_alpha'], details['cell_beta'],
                                                             details['cell_gamma'])],
                                 ['Mosaicity', details['mosaicity']],
                                 ['Spot deviation', details['sigma_spot']],
                                 ['Spindle deviation', details['sigma_angle']],
                                 details.get('ice_rings') != -1 and ['Ice Rings', details['ice_rings']]
                        ],
                        'header': 'column',
                    },
                    {
                        'title': 'Expected Quality[3]',
                        'kind': 'table',
                        'style': 'col-6',
                        'data': [['Resolution (A)[4]', details.get('strategy',{}).get('resolution')],
                                 ['Multiplicity', details.get('strategy',{}).get('multiplicity')],
                                 ['Completeness', details.get('strategy',{}).get('completeness')],
                                 ['I/Sigma (I)', details.get('strategy',{}).get('i_sigma')],
                                 ['R-factor', details.get('strategy',{}).get('r_factor')],
                                 ['Fraction overloaded', details.get('strategy',{}).get('frac_overload')],
                                 ],
                        'header': 'column',
                    },
                    {
                        'title': "Kappa and Phi angles for re-orienting the crystal",
                        'kind': 'table',
                        'style': 'col-12',
                        'data': [['Kappa[*]', 'Phi', 'Vectors (v1,v2)[*]']].extend(details.get('crystal_alignment',{}).get('solutions',['','',''])),
                        'header': 'row',
                        'notes': """[*] - Alignment is calculated for the goniometer 'CLS MiniKappa'. The alignment method is v1 parallel to omega, v2 perpendicular to the omega-beam plane.""",
                    },
                    {
                        'title': "Compatible bravais lattice types",
                        'kind': 'table',
                        'style': 'col-12',
                        'data': [['No.', 'Lattice type', 'Cell Parameters', 'Quality', 'Cell Volume']] + [
                            [id, details['compatible_lattices']['type'][i],
                             details['compatible_lattices']['unit_cell'][i], details['compatible_lattices']['quality'][i],
                             details['compatible_lattices']['volume'][i]]
                            for i, id in enumerate(details['compatible_lattices']['id'])
                            ],
                        'header': 'row',
                    },
                    {
                        'title': "Automatic Space-Group Selection",
                        'kind': 'table',
                        'style': 'col-12',
                        'data': [['Selected','Candidates','Space Group No.','Probability']] + [
                            [prob == max(details['spacegroup_selection']['probability']) and '*' or '',
                             details['spacegroup_selection']['name'][i],
                             details['spacegroup_selection']['space_group'][i],
                             prob,
                            ]
                        for i, prob in enumerate(details['spacegroup_selection']['probability'])],
                        'header': 'row',
                        'notes': """The above table contains results from POINTLESS (see Evans, Acta Cryst. D62, 72-82, 2005). Indistinguishable space groups will have similar probabilities. If two or more of the top candidates have the same probability, the one with the fewest symmetry assumptions is chosen. This usually corresponds to the point group,  trying out higher symmetry space groups within the top tier does not require re-indexing the data as they are already in the same setting. For more detailed results, please inspect the output file 'pointless.log'."""
                    }
                ]
            },
            details.get('predicted_quality') and {
                'title': "Predicted statistics for suggested strategy by resolution",
                'content': [
                    {
                        'kind': 'lineplot',
                        'data':
                            {
                                'x': ['']+ details['predicted_quality']['shell'],
                                'y1': [['Completeness (%)']+ details['predicted_quality']['completeness']],
                                'y2': [['R-factor (%)']+ details['predicted_quality']['r_factor']],
                                'x-scale': 'inv-square'
                            }
                    },
                    {
                        'kind': 'lineplot',
                        'data':
                            {
                                'x': ['Resolution Shell']+ details['predicted_quality']['shell'],
                                'y1': [['I/Sigma(I)']+ details['predicted_quality']['i_sigma']],
                                'y2': [['Multiplicity']+ details['predicted_quality']['multiplicity']],
                                'x-scale': 'inv-square'
                            },
                        'notes': "The above plot was calculated by BEST. See A.N. Popov and G.P. Bourenkov Acta Cryst. (2003). D59, 1145-1153, G.P. Bourenkov and A.N. Popov Acta Cryst. (2006). D62, 58-64"
                    },
                    {
                        'kind': 'table',
                        'data': [['Shell','Completeness','R-factor','I/Sigma(I)','Multiplicity','Overload Fraction']] + [
                            [shell, details['predicted_quality']['completeness'][i],details['predicted_quality']['r_factor'][i],details['predicted_quality']['i_sigma'][i],details['predicted_quality']['multiplicity'][i],details['predicted_quality']['frac_overload'][i]]
                            for i, shell in enumerate(details['predicted_quality']['shell'])
                         ],
                        'header': 'row',
                        'notes': """I/Sigma - Mean intensity/Sigma of a reflection in shell
                                          R-factor - &Sigma;|I(h,i)-I(h)| / &Sigma;[I(h,i)]"""
                    }
                ],
            },
            details.get('overlap_analysis') and 'angle' in details.get('overlap_analysis', {}) and {
                'title': "Maximum Oscillation width to avoid overlapped spots at different resolutions",
                'content': [
                    {
                        'kind': 'lineplot',
                        'data': {
                            'x': ['Oscillation Angle (deg)']+ details['overlap_analysis']['angle'],
                            'y1': [['{}A'.format(k)]+ v for k, v in details['overlap_analysis'].items() if k != 'angle'],
                            'y1-label': 'Maximum Delta (deg)'
                        },
                        'notes': "The above plot was calculated by BEST. See A.N. Popov and G.P. Bourenkov Acta Cryst. (2003). D59, 1145-1153, G.P. Bourenkov and A.N. Popov Acta Cryst. (2006). D62, 58-64 ",
                    },
                ]
            } or {},
            details.get('wedge_analysis') and {
                'title': "Minimal oscillation ranges for different percentages of data completeness",
                'content': [
                    {
                        'kind': 'lineplot',
                        'data': {
                            'x': ['Starting Angle (deg)']+ details['wedge_analysis']['start_angle'],
                            'y1': [['{}%'.format(k)]+ v for k, v in details['wedge_analysis'].items() if k != 'start_angle'],
                            'y1-label': 'Total Oscillation Angle (deg)'
                        },
                        'notes': "The above plot was calculated by BEST. See A.N. Popov and G.P. Bourenkov Acta Cryst. (2003). D59, 1145-1153, G.P. Bourenkov and A.N. Popov Acta Cryst. (2006). D62, 58-64 ",
                    },
                ]
            },
            details.get('exposure_analysis') and {
                'title': "Analysis of exposure time required versus resolution attained",
                'content': [
                    {
                        'kind': 'lineplot',
                        'data': {
                            'x': ['Exposure Time (s)']+ details['exposure_analysis']['exposure_time'],
                            'y1': [['Resolution']+ details['exposure_analysis']['resolution']]
                        },
                        'annotations': [],
                        'notes': "The above plot was calculated by BEST. <br>See A.N. Popov and G.P. Bourenkov Acta Cryst. (2003). D59, 1145-1153, G.P. Bourenkov and A.N. Popov Acta Cryst. (2006). D62, 58-64 ",
                    },
                ]
            },
            details]

            kind = "{}Screening".format(details.get('anomalous') and 'Anomalous ' or "")
            AnalysisReport.objects.filter(pk=r.pk).update(details=screen_details, kind=kind)
